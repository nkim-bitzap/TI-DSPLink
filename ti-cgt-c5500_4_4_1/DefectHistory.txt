TMS320C55x Code Generation Tools Release Version 4.4.1
Defect History
March 2012

------------------------------------------------------------------------------
Table of Contents
------------------------------------------------------------------------------
1. 4.4.1 Fixed Defects
2. 4.4.0 Fixed Defects
3. 4.4.0B1 Fixed Defects
4. 4.3.0B1 Fixed Defects
5. Current Known Issues


------------------------------------------------------------------------------
1. 4.4.1 Fixed Defects
------------------------------------------------------------------------------

------------------------------------------------------------------------------
FIXED  SDSCM00037170
------------------------------------------------------------------------------

Summary            : Embed does not handle cross-filesystem rename correctly

Fixed in           : 4.4.1
Severity           : S2 - Major
Affected Component : Embed Utility

Description: 
The embed utility needs to copy the file across file systems before
renaming it.

------------------------------------------------------------------------------
FIXED  SDSCM00038808
------------------------------------------------------------------------------

Summary            : C55x circular addressing starting mid-object results in
		     incorrect wrap

Fixed in           : 4.4.1
Severity           : S2 - Major
Affected Component : Optimizer

Description: 
A loop that uses circular addressing for C55x (eg, refers to a[i] and 
uses i = (i+1)%10) may wrap around to the wrong starting index if array
a is actually a pointer to the middle of another object (eg, &v[1]), the 
pointer is passed as a function parameter, and it is a constant
argument but the call does not inline.

------------------------------------------------------------------------------
FIXED  SDSCM00040101
------------------------------------------------------------------------------

Summary            : Compiler generates temporary files when compiling C++ files
		     with templates and -pm that are not automatically deleted

Fixed in           : 4.4.1
Severity           : S3 - Minor
Affected Component : C/C++ Compiler (cl)

Description: 
When compiling C++ files which use templates with -pm option the
compiler generates temporary files that are not automatically deleted.

------------------------------------------------------------------------------
FIXED  SDSCM00040151
------------------------------------------------------------------------------

Summary            : Getting compile time generated symbol re-definition error
		     during linking 

Fixed in           : 4.4.1
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Description: 
The linker may generate "duplicate symbol" errors for symbols named
like _TI_DW_.debug_info.<checksum> when linking object files.  Using ofd, it
can be seen that these symbols are signatures for COMDAT groups.  This
is an error in COMDAT generation in the assembler and linker.

------------------------------------------------------------------------------
FIXED  SDSCM00040650
------------------------------------------------------------------------------

Summary            : Error when specifying 400 or more to precision of output
		     format specifier

Fixed in           : 4.4.1
Severity           : S3 - Minor
Affected Component : C/C++ Compiler (cl)

Description: 
The minimum max conversion (precision) printf size to be C89 compliant
is 509.   The conversion size is now C89 compliant.

------------------------------------------------------------------------------
FIXED  SDSCM00041776
------------------------------------------------------------------------------

Summary            : Optimizer substitutes packed bitfield reference without
		     masking value at -o1

Fixed in           : 4.4.1
Severity           : S2 - Major
Affected Component : Optimizer

Description: 
Under certain specific circumstances, the compiler may replace an
assignment to a bitfield with a temporary variable whose value has not
been properly truncated as the original assignment did.  To cause the
bug, several passes that do the right thing must be inhibited;	one
known way is to use -o1 and a packed struct.

------------------------------------------------------------------------------
FIXED  SDSCM00041971
------------------------------------------------------------------------------

Summary            : Spurious remark generated from __STDC_VERSION__ ref in
		     stddef.h in C++ mode

Fixed in           : 4.4.1
Severity           : S3 - Minor
Affected Component : Runtime Support Libraries (RTS)

Description: 
#include <stddef.h>

int main(void)
{
    return 2;
}

When compiling generates:

include/stddef.h", line 87 remark #195-D zero
	  used for undefined preprocessing identifier
      (__STDC_VERSION__ >= 199901L || !__TI_STRICT_ANSI_MODE__)

This happens because __STDC_VERSION__ is not defined in C++ mode

------------------------------------------------------------------------------
FIXED  SDSCM00042061
------------------------------------------------------------------------------

Summary            : Library building fails when TEMP is moderately long (50+
		     characters)

Fixed in           : 4.4.1
Severity           : S1 - Critical / PS
Affected Component : Runtime Support Libraries (RTS)

Description: 
The archiver command line is over 32k characters, which runs afoul of the
insurmountable upper limit of the Win32 API CreateProcess.  

------------------------------------------------------------------------------
FIXED  SDSCM00042103
------------------------------------------------------------------------------

Summary            : Dynamic linking options should be hidden for non-C6000
		     targets

Fixed in           : 4.4.1
Severity           : S3 - Minor
Affected Component : Linker

Description: 
Dynamic linking is not supported for any target but C6000, but the
dynamic linking options were exposed in the shell and linker option
help summary output.  Ignore them.

------------------------------------------------------------------------------
FIXED  SDSCM00042146
------------------------------------------------------------------------------

Summary            : Quotes in PATH, TEMP, etc on Windows breaks mklib

Fixed in           : 4.4.1
Severity           : S2 - Major
Affected Component : Runtime Support Libraries (RTS)

Description: 
If the PATH environment variable has quotes in it, mklib will crash
with a mysterious error like "CreateProcess(NULL, cl470 atexit.c ...) 
failed.  The system cannot find the file specified."  It is not legal
to have literal quotes in PATH, but as an enhancement, mklib will
attempt to remove quotes from PATH and try again.

------------------------------------------------------------------------------
FIXED  SDSCM00042340
------------------------------------------------------------------------------

Summary            : Compiler mistakenly issues diagnostic about destructor for
		     base class is not virtual

Fixed in           : 4.4.1
Severity           : S3 - Minor
Affected Component : C/C++ Compiler (cl)

Description: 
The no virtual base class destructor diagnostic will no longer be
emitted when the base class has a virtual destructor.  

------------------------------------------------------------------------------
FIXED  SDSCM00042368
------------------------------------------------------------------------------

Summary            : Parser generates segmentation fault

Fixed in           : 4.4.1
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Description: 
Parser generates segmentation fault when compiling the following source
file

static const int a[1];

int main(void)
{
    (void)a[0];

    return 0;
}

static const int a[1] = { 0 };

------------------------------------------------------------------------------
FIXED  SDSCM00042563
------------------------------------------------------------------------------

Summary            : Optimiser crashes on certain loop cases

Fixed in           : 4.4.1
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Description: 
Certain loop structures, which we are not able to describe concisely,
can cause the optimiser to crash when compiling at -o2 or higher.  The
one known example involves C++ code and a lot of inlining;  adjusting
the inlining avoids the problem.

------------------------------------------------------------------------------
FIXED  SDSCM00042570
------------------------------------------------------------------------------

Summary            : Missing MISRA 19.15

Fixed in           : 4.4.1
Severity           : S3 - Minor
Affected Component : C/C++ Compiler (cl)

Description: 
MISRA 19.15 not selectable in CCS v5.1.

------------------------------------------------------------------------------
FIXED  SDSCM00042645
------------------------------------------------------------------------------

Summary            : Section splitting causes linker to not pad code sections
		     with serial NOPs.	This leads to unpredictable code 
                     execution.

Fixed in           : 4.4.1
Severity           : S2 - Major
Affected Component : Linker


------------------------------------------------------------------------------
FIXED  SDSCM00042691
------------------------------------------------------------------------------

Summary            : __swapf() intrinsic failure for -o1 and higher

Fixed in           : 4.4.1
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Description: 
The __swapf intrinsic, and possibly other intrinsics that both read and
write their arguments, will compile incorrectly with optimisation if a 
memory reference (ie, not a simple variable) is used as argument.

------------------------------------------------------------------------------
FIXED  SDSCM00042811
------------------------------------------------------------------------------

Summary            : printf("%d") with negative values incorrect for
		     printf_support=minimal

Fixed in           : 4.4.1
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Description: 
printf("%d") is treated as printf("%u") for --printf_support=minimal,
which means negative values will be printed incorrectly.


------------------------------------------------------------------------------
2. 4.4.0 Fixed Defects
------------------------------------------------------------------------------

------------------------------------------------------------------------------
FIXED  SDSCM00034217
------------------------------------------------------------------------------

Summary            : Failure in test case with unroll-and-jam variations

Fixed in           : 4.4.0
Severity           : S2 - Major
Affected Component : Code Generator

Description: 
Certain loop codes may be unrolled either due to a pragma UNROLL or an 
optimization and result in an incorrect dualMAC machine instruction
being generated.  This can only occur for a C55x+ target, NOT a C55x target.

------------------------------------------------------------------------------
FIXED  SDSCM00040072
------------------------------------------------------------------------------

Summary            : app fails C55 large model (incorrect handling of wide
		     mult with int operands)

Fixed in           : 4.4.0
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Description: 
In certain situations a 32- (long) or 40-bit (long long) multiply which
has 16-bit (int, short or char) operands can result in bad code
generation.

------------------------------------------------------------------------------
FIXED  SDSCM00040151
------------------------------------------------------------------------------

Summary            : Getting compile time generated symbol re-definition error
		     during linking 

Fixed in           : 4.4.0
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Description: 
The linker may generate "duplicate symbol" errors for symbols named
like _TI_DW_.debug_info.<checksum> when linking onject files.  

------------------------------------------------------------------------------
FIXED  SDSCM00040164
------------------------------------------------------------------------------

Summary            : app hangs on C55 (illegal speculation of a MAR)

Fixed in           : 4.4.0
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Description: 
When compiling for Small Memory Model for a rev 3.x CPU, conditional 
branching in the source code can result in instruction predication in
the generated code and which incorrectly performs address arithmetic which 
can provoke mayhem.

------------------------------------------------------------------------------
FIXED  SDSCM00040436
------------------------------------------------------------------------------

Summary            : Incorrect relocation value for C55x same-section reference
		     to symbol in a data section

Fixed in           : 4.4.0
Severity           : S2 - Major
Affected Component : ELF Linker

Description: 
When a relocatable symbol defined in a C55x data section is referenced
from within the same section, the relocated value is incorrect.  The
byte address of the base of the section is added to the word offset of
the symbol within the section.	Since the reference is in a data
section the word address of the symbol should have been used in the
relocation.

------------------------------------------------------------------------------
FIXED  SDSCM00040658
------------------------------------------------------------------------------

Summary            : Taking the address of a static local variable may lead to a
		     missed alias

Fixed in           : 4.4.0
Severity           : S2 - Major
Affected Component : Optimizer

Description: 
Accessing a static local variable both directly and indirectly, by
taking its address, may miss an alias and produce incorrect behavior.

------------------------------------------------------------------------------
FIXED  SDSCM00040665
------------------------------------------------------------------------------

Summary            : Anonymous function call that can resolve to direct pure
		     call may cause compiler crash

Fixed in           : 4.4.0
Severity           : S2 - Major
Affected Component : Optimizer

Description: 
If an anonymous function call -- a call using a pointer-to-function 
variable rather than a direct function name -- can be resolved to a 
direct call to a known function with no side effects, in some cases the
compiler may crash.

------------------------------------------------------------------------------
FIXED  SDSCM00040908
------------------------------------------------------------------------------

Summary            : Hex converter crashes with segmentation fault

Fixed in           : 4.4.0
Severity           : S2 - Major
Affected Component : Hex Converter (hex)

Description: 
Hex converter crashes with segmentation fault if more than 15 --exclude
options are used.

------------------------------------------------------------------------------
FIXED  SDSCM00041395
------------------------------------------------------------------------------

Summary            : scanf %1f should stop after one character

Fixed in           : 4.4.0
Severity           : S3 - Minor
Affected Component : Runtime Support Libraries (RTS)

Description: 
The scanf format %1f should stop after one character of input, but it 
ignores the field width and keeps parsing as long as the input looks
like a floating-point number.

------------------------------------------------------------------------------
FIXED  SDSCM00041396
------------------------------------------------------------------------------

Summary            : sscanf(" ", "%s", arg) should not modify arg

Fixed in           : 4.4.0
Severity           : S3 - Minor
Affected Component : Runtime Support Libraries (RTS)

Description: 
When the scanf format %s is used, if there are no non-whitespace 
characters in the input, the conversion should fail and should not
modify the argument.

------------------------------------------------------------------------------
FIXED  SDSCM00041397
------------------------------------------------------------------------------

Summary            : scanf %4[..] consumes 5 characters

Fixed in           : 4.4.0
Severity           : S3 - Minor
Affected Component : Runtime Support Libraries (RTS)

Description: 
With a format string containing a %[ conversion specifier with field
width, and input containing a sequence of characters that matches the
scanset and has more characters than the field width, a call to vfscanf
shall assign the number of characters equal to the field width to the
corresponding pointer to character array leaving characters after the
input item unread. 7.19.6.9;2a (161)	

The bug here is that, while _scanfi assigns the correct number of 
characters, it fails to unget the following character, which belongs to
the next conversion.

------------------------------------------------------------------------------
FIXED  SDSCM00041398
------------------------------------------------------------------------------

Summary            : scanf %[..] matching failure should return immediately

Fixed in           : 4.4.0
Severity           : S3 - Minor
Affected Component : Runtime Support Libraries (RTS)

Description: 
When a conversion fails, scanf should return immediately.  In these
test cases, scanf erroneously keeps going.  scanf eventually reports a
return value that is too large.

------------------------------------------------------------------------------
FIXED  SDSCM00041442
------------------------------------------------------------------------------

Summary            : printf("%#.4o",345) adds too many zeros

Fixed in           : 4.4.0
Severity           : S3 - Minor
Affected Component : Runtime Support Libraries (RTS)

Description: 
When using the # printf format flag, printf should only add an extra
"0" at the beginning of the number if it isn't already "0".

------------------------------------------------------------------------------
FIXED  SDSCM00041447
------------------------------------------------------------------------------

Summary            : printf("%#.0o",0) fails to write "0"

Fixed in           : 4.4.0
Severity           : S3 - Minor
Affected Component : Runtime Support Libraries (RTS)

Description: 
For *printf functions, the C standard requires that if the value is 0,
the precision is 0, and the # flag is used, a single "0" will be
printed.

------------------------------------------------------------------------------
FIXED  SDSCM00041550
------------------------------------------------------------------------------

Summary            : sscanf %% failure not handled correctly

Fixed in           : 4.4.0
Severity           : S3 - Minor
Affected Component : Runtime Support Libraries (RTS)

Description: 
When any sort of error occurs with %%, scanf immediately returns EOF. 
It should instead return EOF only if there were 0 previous successful
conversions and there was an input failure.  If the failure was either
a matching failure, or there were any previous successful conversions,
it should return the number of previous successful conversions.

When the failure is a matching failure, scanf should unget the
character that didn't match.  It fails to do so.

------------------------------------------------------------------------------
FIXED  SDSCM00041551
------------------------------------------------------------------------------

Summary            : scanf %d and %f should immediately return upon input
		     failure, even if ordinary characters were matched

Fixed in           : 4.4.0
Severity           : S3 - Minor
Affected Component : Runtime Support Libraries (RTS)

Description: 
scanf should immediately return when an input failure occurs, even if 
ordinary characters in the format were already successfully matched. 
This bug affects all of the integer and float conversions.

------------------------------------------------------------------------------
FIXED  SDSCM00041552
------------------------------------------------------------------------------

Summary            : sscanf.c _chkmbc should return EOF on input failure

Fixed in           : 4.4.0
Severity           : S3 - Minor
Affected Component : Runtime Support Libraries (RTS)

Description: 
It should be possible for sscanf to return EOF on a string if an input
error occurs (the end of the input string is reached before the format
string is exhausted), but it does not return EOF as appropriate.

------------------------------------------------------------------------------
FIXED  SDSCM00041553
------------------------------------------------------------------------------

Summary            : scanf input failure when looking for ordinary characters
		     always returns EOF

Fixed in           : 4.4.0
Severity           : S3 - Minor
Affected Component : Runtime Support Libraries (RTS)

Description: 
When matching ordinary characters in the format string, if there is an
input failure, scanf should return EOF only if there were no previous
successful conversions.  If there were any, it should return the
number of previous successful conversions.

------------------------------------------------------------------------------
FIXED  SDSCM00041554
------------------------------------------------------------------------------

Summary            : scanf %e and %[ should not return EOF on matching failure

Fixed in           : 4.4.0
Severity           : S3 - Minor
Affected Component : Runtime Support Libraries (RTS)

Description: 
When using %f (or other floating-point conversion specifier) or %[, if
a matching failure occurs before even one character is matched, scanf
will return EOF instead of 0 as the standard requires.


------------------------------------------------------------------------------
3. 4.4.0B1 Fixed Defects
------------------------------------------------------------------------------

------------------------------------------------------------------------------
FIXED  SDSCM00040365
------------------------------------------------------------------------------

Summary            : Mixing direct and indirect accesses to same variable may
		     give wrong answer

Fixed in           : 4.4.0B1
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Description: 
Referring to the same variable both directly and indirectly -- eg,
given p[0]=&a, using both *p[0] and a in the same function -- may produce the
wrong answer when the alias between the two references is missed.

Defect occurs in
C5500 Compiler versions 3.2.0B3 - 3.2.3, 3.3.0 - 3.3.6, 4.0.0B1 -
4.0.2, 4.1.0B1 - 4.1.2, 4.2.0B1 - 4.2.3, 4.3.0B1 - 4.3.9

------------------------------------------------------------------------------
FIXED  SDSCM00040369
------------------------------------------------------------------------------

Summary            : Assignment to local struct variable with recurrence may
		     assign some fields incorrectly

Fixed in           : 4.4.0B1
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Description: 
Given a struct type that contains a pointer to the same type, as in
  struct st {
      struct st *next;
      int    val;
  }

and a local variable X of that type, and an assignment to that variable like
  X = *(X.next);

some fields of X may not be written correctly.	(Because X.next is
written before the read of *(X.next) has completed.)

------------------------------------------------------------------------------
FIXED  SDSCM00040372
------------------------------------------------------------------------------

Summary            : Variable with volatile inside loop resulted in codegen
		     INTERNAL ERROR.

Fixed in           : 4.4.0B1
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Description: 
Fix is currently scheduled for 7.2.5 update planned 7/29/11 and 6.1.20
update planned for 8/5/11.

------------------------------------------------------------------------------
FIXED  SDSCM00040615
------------------------------------------------------------------------------

Summary            : cg55 SIGSEGV on large array declaration

Fixed in           : 4.4.0B1
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Description: 
Reduce the attempted number of array elements placed in a .cinit record. 

------------------------------------------------------------------------------
FIXED  SDSCM00040623
------------------------------------------------------------------------------

Summary            : Mixing direct and indirect accesses to same variable may
		     give wrong answer

Fixed in           : 4.4.0B1
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Description: 
Referring to the same variable both directly and indirectly -- eg,
given p=&a, using both *p and a in the same function -- may produce the wrong
answer when the alias between the two references is missed.

Defect occurs in
C5500 Compiler versions 3.2.0B3 - 3.2.3, 3.3.0 - 3.3.6, 4.0.0B1 -
4.0.2, 4.1.0B1 - 4.1.2, 4.2.0B1 - 4.2.3, 4.3.0B1 - 4.3.9

------------------------------------------------------------------------------
FIXED  SDSCM00040651
------------------------------------------------------------------------------

Summary            : Return statement with embedded assignment from a
		     post-increment or -decrement may
		     return wrong value

Fixed in           : 4.4.0B1
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Description: 
A statement like "return j = i++" may return the value of i after it
has been incremented, when it should return the value before the increment.
It's possible that other cases exist, but all will involve an assignment 
of a post-increment or post-decrement embedded in another statement.

Defect occurs in
C5500 Compiler versions 2.70 - 2.84, 3.2.0B3 - 3.2.3, 3.3.0 - 3.3.6,
4.0.0B1 - 4.0.2, 4.1.0B1 - 4.1.2, 4.2.0B1 - 4.2.3, 4.3.0B1 - 4.3.9

------------------------------------------------------------------------------
FIXED  SDSCM00040659
------------------------------------------------------------------------------

Summary            : Mixing direct and indirect accesses to same variable may
		     give wrong answer

Fixed in           : 4.4.0B1
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Description: 
Referring to the same variable both directly and indirectly -- eg,
given p=&a, using both *p and a in the same function -- may produce the wrong
answer when the alias between the two references is missed.

Defect occurs in
C5500 Compiler versions 3.2.0B3 - 3.2.3, 3.3.0 - 3.3.6, 4.0.0B1 -
4.0.2, 4.1.0B1 - 4.1.2, 4.2.0B1 - 4.2.3, 4.3.0B1 - 4.3.9

------------------------------------------------------------------------------
FIXED  SDSCM00040665
------------------------------------------------------------------------------

Summary            : Anonymous function call that can resolve to direct pure
		     call may cause compiler crash

Fixed in           : 4.4.0B1
Severity           : S2 - Major
Affected Component : Optimizer

Description: 
If an anonymous function call -- a call using a pointer-to-function 
variable rather than a direct function name -- can be resolved to a 
direct call to a known function with no side effects, in some cases the
compiler may crash.

Defect occurs in
C5500 Compiler versions 4.2.0B1 - 4.2.3, 4.3.0B1 - 4.3.9, 4.4.0B1

------------------------------------------------------------------------------
FIXED  SDSCM00040750
------------------------------------------------------------------------------

Summary            : Peren C++ test case crashes cg6x

Fixed in           : 4.4.0B1
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Description: 
An preventative internal assertion error during new compiler
development was encountered.  This defect very likely cannot cause any problems 
on any released compilers because of the way the algorithm in question can
recover from this situation.  This defect is being fixed on existing compilers 
simply as a precaution and users should notice no difference in
compiler behavior or output.

Defect occurs in
C5500 Compiler versions 4.3.0B1 - 4.3.9

------------------------------------------------------------------------------
FIXED  SDSCM00041442
------------------------------------------------------------------------------

Summary            : printf("%#.4o",345) adds too many zeros

Fixed in           : 4.4.0B1
Severity           : S3 - Minor
Affected Component : Runtime Support Libraries (RTS)

Description: 
When using the # printf format flag, printf should only add an extra
"0" at the beginning of the number if it isn't already "0".

Defect occurs in
C5500 Compiler versions 2.70 - 2.84, 3.2.0B3 - 3.2.3, 3.3.0 - 3.3.6,
4.0.0B1 - 4.0.2, 4.1.0B1 - 4.1.2, 4.2.0B1 - 4.2.3, 4.3.0B1 - 4.3.9,

------------------------------------------------------------------------------
4. 4.3.0B1 Fixed Defects
------------------------------------------------------------------------------

------------------------------------------------------------------------------
FIXED  SDSCM00025030
------------------------------------------------------------------------------

Summary            : Parser does not generate error for declaration after
		     executable statement when compiling in relaxed ANSI mode

Fixed in           : 4.3.0B1
Severity           : S2 - Major
Affected Component : Parser

Description: 
The parser will not generate an error in relaxed mode for a declaration
made after a statement.  For example

a = b + c;
int i = 0;

will not generate an error with the -pr switch.  The fix for the bug is
that the parser diagnostic switches can be used to enable this error.

-pr -pdse=270 will generate an error
-pr -pdsw=270 will generate a warning
-pr -pdsr=270 will generate a remark

------------------------------------------------------------------------------
FIXED  SDSCM00025285
------------------------------------------------------------------------------

Summary            : Linker does not honor allocation based on memory attribute
		     of a region

Fixed in           : 4.3.0B1
Severity           : S3 - Minor
Affected Component : Linker

Description: 
Linker does not honor allocation based on memory attribute of a region.

For example,
MEMORY
{
    ROM (RW)  org = 0x00000020	 len = 0x00005000  /* ROM */
    RAM (RX)  org = 0x00006000	 len = 0x0007FFE0  /* SYSTEM RAM    */
}

SECTIONS
{
    .text     {} > (RX) 
}

This should allocate the .text section to any memory range that has the
attribute RX. 

If a memory attribute is specified for allocation the linker will match
any memory region that has the 'R' attribute specified.

------------------------------------------------------------------------------
FIXED  SDSCM00025372
------------------------------------------------------------------------------

Summary            : The -h linker option hides undefined references

Fixed in           : 4.3.0B1
Severity           : S2 - Major
Affected Component : Linker

Description: 
The linker hides unresolved symbols with the -h switch during a partial
link.

------------------------------------------------------------------------------
FIXED  SDSCM00025652
------------------------------------------------------------------------------

Summary            : Using --beginopts --endopts on function not in source file
		     unexpectedly affects how code is generated

Fixed in           : 4.3.0B1
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

------------------------------------------------------------------------------
FIXED  SDSCM00025712
------------------------------------------------------------------------------

Summary            : Compiler crashes on zero-length array GCC extension

Fixed in           : 4.3.0B1
Severity           : S2 - Major
Affected Component : Code Generator

Description: 
The cinit record generation wasn't accounting for zero-length arrays.
Due to this, a computation that divided an entity by the array length, 
triggered a divide by zero floating point exception. Fixed.

------------------------------------------------------------------------------
FIXED  SDSCM00025912
------------------------------------------------------------------------------

Summary            : Incorrect result when code compiled with large memory
		     option

Fixed in           : 4.3.0B1
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Description: 
In expressions involving differences between data pointers and array 
offsets an optimization pass failed to treat the type of the expression
as ptrdiff_t when rewriting the expression.  As a result the wrong 
register was used when setting up the multiply (call to RTS long
multiply routine).  The problem is specific to this type of expression and 
compiling with -ml without using the optimizer (-o). 

------------------------------------------------------------------------------
FIXED  SDSCM00025935
------------------------------------------------------------------------------

Summary            : Optimizer terminated abnormally with "-o3" option

Fixed in           : 4.3.0B1
Severity           : S3 - Minor
Affected Component : C/C++ Compiler (cl)

Description: 
Under certain obscure circumstances, an expression used as an argument
to memcpy() can be mishandled in such a way that it fails a memcpy()-specific 
sanity check and causes an optimiser abort.  The circumstances involve memcpy() 
and a literal constant that appears in the argument and also elsewhere in the 
function.

------------------------------------------------------------------------------
FIXED  SDSCM00026414
------------------------------------------------------------------------------

Summary            : Optimizer generates incorrect code for bitwise AND operator

Fixed in           : 4.3.0B1
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Description: 
The optimiser will erroneously transform "((1 << x) & y) == 1" into
"((y >> x) & 1) == 1" which is not equivalent.


------------------------------------------------------------------------------
5. Current Known Issues
------------------------------------------------------------------------------

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00008248
------------------------------------------------------------------------------

Summary            : Compilers on PC will not work without TMP set
Affected Component : C/C++ Compiler

Description: 
When compiling on the PC, the code generator cannot find the icode 
file produced by the parser if the environment variable TMP is no 
set.  

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00008251
------------------------------------------------------------------------------

Summary            : Printf format '%#04x' fills zeros into wrong location
Affected Component : Code Generator

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00008525
------------------------------------------------------------------------------

Summary            : Float literal conversion to integers incorrectly saturates
		     at 32 bits
Affected Component : Parser

Description: 
The parser floating-point folding routines always use native 'long' as 
the integer type to fold a float constant to.  For a constant like 
5e11, the constant will be folded to host LONG_MAX, or about 2e9, even though
5e11 is under C6x LONG_MAX and C55x LLONG_MAX.

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00008543
------------------------------------------------------------------------------

Summary            : Forward reference in .space generates an internal error
Affected Component : Assembler

Description: 
If you attempt to assemble

 .space 0+a
b
a .set 1

the assembler will generate an internal error.

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00008588
------------------------------------------------------------------------------

Summary            : Assembler remark regarding CPU_84 not generated when
		     -vcore2.0 used
Affected Component : Assembler

Description: 
ASM55 fails to produce the needed REMARK when certain -v options are 
used.

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00008591
------------------------------------------------------------------------------

Summary            : hex file writes wrong data at eof section, for odd value
		     section length
Affected Component : Hex Converter

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00008618
------------------------------------------------------------------------------

Summary            : Codegen 'no match' for circular addressing on arrays of
		     structs
Affected Component : Code Generator

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00008631
------------------------------------------------------------------------------

Summary            : Asm fails to issue error message when .if looks at
		     undefined symbols
Affected Component : Mnemonic Assembler

Description: 
When .if is applied to relocatable symbols, the assembler should
complain with an error message.  When masm55 sees .if applied to
symbols that are defined later, or even not defined at all, it
fails to issue the error message.  

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00008748
------------------------------------------------------------------------------

Summary            : masm internal error when non-existent file is argument to
		     -ahi
Affected Component : Shell

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00008771
------------------------------------------------------------------------------

Summary            : Optimizer can cause array element access on wrong data
		     page on C55x rev 1 or 2
Affected Component : Code Generator

Description: 
There is a case, with an array of structures, that the optimizer will 
cause an array access to be executed at the incorrect address when
compiled for C55x rev 1 or rev 2

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00008928
------------------------------------------------------------------------------

Summary            : Extern inline functions are not supported in the C/C++
		     Compiler
Affected Component : Parser

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00009815
------------------------------------------------------------------------------

Summary            : printf gives wrong value for pointer when its value is
		     incremented
Affected Component : C/C++ Compiler

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00010435
------------------------------------------------------------------------------

Summary            : asm55 SIGSEGV ".mlib" and macro with colon after the name
Affected Component : Assembler

Description: 
If the name of the macro does not exactly match the name used to invoke
the macro (for instance, if in the definition of the macro, the macro
name is followed by a colon), the assembler crashes with a SIGSEGV.  

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00012038
------------------------------------------------------------------------------

Summary            : Should emit a diagnostic when direct memory operand
		     constant out of range
Affected Component : Assembler

Description: 
The assembler checks constant offsets for Smem memory operands, but
doesn't correctly check the range of direct memory or Baddr-direct
operands.  Instead, it silently truncates them.

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00013456
------------------------------------------------------------------------------

Summary            : fgets in _IONBF mode does not respect size limit
Affected Component : Runtime Support Libraries (RTS)

Description: 
The second argument to fgets() is the maximum number of chars to read. 
In _IONBF mode, fgets() reads until end-of-line, potentially
overrunning the input buffer.  

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00014430
------------------------------------------------------------------------------

Summary            : calloc doesn't check arguments to make sure the requested
		     size is reasonable
Affected Component : Runtime Support Libraries (RTS)

Description: 
The function calloc() is required to return a pointer to memory
representing "nelem" copies of "size" bytes, or NULL if the request
cannot be satisfied.  However, for some values of "nelem" and "size"
(specifically when the result of nelem*size wraps around), calloc can
return a pointer to an object that is not large enough, rather than
NULL.

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00016646
------------------------------------------------------------------------------

Summary            : strcmp doesn't correctly handle values with uppermost bit
		     set
Affected Component : Runtime Support Libraries (RTS)

Description: 
The standard says "The sign of a nonzero value returned by the
comparison functions memcmp, strcmp, and strncmp is determined by the
sign of the difference between the values of the first pair of
characters (both interpreted as unsigned char) that differ in the
objects being compared."  However, this is a problem for 16-bit targets
where the size of char is the same as the size of int.	In this case,
it's easy to mistakenly use an unsigned subtract to do the comparison
and return it directly; this value can overflow.

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00017401
------------------------------------------------------------------------------

Summary            : bit(ST3, #3) disassembled as bit(ST3, #ST3_BPTR), which
		     assembler rejects
Affected Component : Disassembler

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00018666
------------------------------------------------------------------------------

Summary            : ofd55 reports invalid alignment for section with outrageous
		     alignment requirement
Affected Component : Assembler

Description: 
A C55x section with alignment 32768 is incorrectly reported by ofd55 as
having alignment of 1.	

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00018691
------------------------------------------------------------------------------

Summary            : Linker gives misleading warning when dot expressions used
		     in SECTION directive for .stack section
Affected Component : Linker

Description: 
Linker gives the warning
warning creating ".stack" section with default size of 0x800; use the
-stack option to change the default size even when the application does 
not link in boot code from RTS lib.

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00019609
------------------------------------------------------------------------------

Summary            : cl55 should reject attempts to change calling convention
		     for Phase 2
Affected Component : Shell

Description: 
When using -vP2, the option -call=c55_std is accepted and ignored; we
should get a error.

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00019653
------------------------------------------------------------------------------

Summary            : Disassembler does not extract symbolic information from
		     .out file when load and run address of section are 
		     different
Affected Component : Disassembler

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00019995
------------------------------------------------------------------------------

Summary            : Ordering problem with --byte_with_word_mode
Affected Component : Linker

Description: 
The linker option --byte_with_word_mode is positional.	This means as
presently implemented, it must come before all word-mode inputs.  In
addition, some byte mode input must occur on the linker command line
before all word-mode inputs.  Thus, the following perfectly reasonable
use cases are illegal, and will give the user an unexpected error

cl55 -vcore+ --memory_model=huge other_word.asm -z
--byte_with_word_mode hello_byte.obj -lrts55phb.lib
cl55 -vcore+ --memory_model=huge --byte_mode hello_byte.c -z
other_word.obj --byte_with_word_mode -lrts55phb.lib

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00020176
------------------------------------------------------------------------------

Summary            : Call to strxfrm with C5500 -vcore3 option leads to run-time
		     Invalid CIO command (0) messages
Affected Component : C/C++ Compiler

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00021322
------------------------------------------------------------------------------

Summary            : Compiler randomly crashes when building code on PC 
Affected Component : Shell

Description: 
When performing a build from a Windows command prompt, the compiler
randomly crashes. 

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00022595
------------------------------------------------------------------------------

Summary            : Linker does not accept assignment expressions involving
		     "opequals"
Affected Component : Linker

Description: 
The new linker does not accept the "+=" "-=" "*=" "/=" operators for
assignment expressions.

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00022690
------------------------------------------------------------------------------

Summary            : Internal error
Affected Component : Linker

Description: 
A linker command file which begins with "*" will cause an internal
error.

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00022724
------------------------------------------------------------------------------

Summary            : Copy table record report in map file shows incorrect units
		     for source and dest addresses
Affected Component : Linker

Description: 
The addresses in a C55x copy table are always encoded as word
addresses, regardless of what kind of section is involved, or whether
it's word or byte mode.  In the map file, the addresses are always
reported by the old linker as word addresses.  In the new linker,
always as  byte addresses.  The format of the map file should follow
the actual copy table record.  HOWEVER, this may be confusing in byte
mode.  Also check the XML linker output.

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00022791
------------------------------------------------------------------------------

Summary            : Should emit warning that a copy table is useless
Affected Component : Linker

Description: 
A linker table created for a section which has the same load and run
address will perform the useless action of copying a section on top of
itself.  The old linker generated an error.  The new linker should emit
a warning, but does not issue any diagnostic.

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00022821
------------------------------------------------------------------------------

Summary            : XML output "addr_size" incorrect for C55x data sections
Affected Component : OFD Utility

Description: 
The XML data is incorrect.  addr_size (which is a per-section datum) is
intended to describe the size in bytes of the addressable unit of that
section.  For C55x word mode data sections, this would be "2." 
However, OFD reports "1" for such sections.	

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00029949
------------------------------------------------------------------------------

Summary            : Incorrect nesting depth causes codegen crash on C55
Affected Component : Code Generator

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00032430
------------------------------------------------------------------------------

Summary            : C55x+ mnemonic assembler accepts certain invalid
		     instructions
Affected Component : Assembler

Description: 
The particular example submitted by the customer is the following
   MOV pair(saturate(HI(AC10))), dbl(*AR2+)

This is encoded as
   MOV pair(AC10.H), dbl(*AR2+)

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00033705
------------------------------------------------------------------------------

Summary            : C55x+ assembler accepts illegal dual MAS instruction
Affected Component : Mnemonic Assembler

Description: 
The following instruction is accepted by the C55x+ assembler
    MASS LO(*AR1), *AR2, AC1  MASS HI(*AR1), *AR2, AC0

and is incorrectly encoded as
    MASS *AR1, *AR2, AC1  MASS *AR1, *AR2, AC0

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00033852
------------------------------------------------------------------------------

Summary            : Linker ver 4.3.4 hangs on linker command file which runs
		     fine with ver 4.1.2 linker
Affected Component : Linker

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00033866
------------------------------------------------------------------------------

Summary            : C5500 for() loop with memory read/write fails with CGT
		     3.2.2 and above, but works with CGT 2.54
Affected Component : Code Generator

Description: 
The C55x does have a memory bypass mechansim that engages when a memory read
for an address occurs within 3 cycles of a write to the same address. (The
value written is returned as the value of the read without accessing memory.)
When the memory accesses are "volatile", as indicated in this case, the
compiler will insert nops to ensure the read is at least 4 cycles after the
write.  In your case (in theory) no extra nops are necessary because the goto
at the end of the loop should take up enough cycles to make them unnecessary.

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00035379
------------------------------------------------------------------------------

Summary            : C++ requires overloaded abs() and div() in stdlib.h
Affected Component : Runtime Support Libraries (RTS)

Description: 
ISO14882 (C++) 26.5 (C Library) requires overloaded versions of a bunch
of standard C functions.  The floating-point counterpart of abs() was
added to math.h, but we also need "long" versions of abs() and div() in
stdlib.h.  

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00035752
------------------------------------------------------------------------------

Summary            : C5500 compiler sometimes emits RPT loops that are illegal
		     asm because the loop count is too big
Affected Component : Code Generator

Description: 
In small model, size_t is unsigned int and object are are absolutely limited
to 65535 (16-bit) bytes.  However, because ptrdiff_t is signed int (as
required by the optimizer for efficiency of pointer operations), subtle C
standard issues disallow declaring any single object larger than 32767.  

In large model, objects can be declared larger than 65535 bytes, yet size_t is
still unsigned int and ptrdiff_t is long.  In this case, it is illegal to
declare objects larger than 65535 bytes, but the parser mistakenly fails to
flag this as an error.  At this time there are no plans to fix this parser
issue.

In either of these cases, the compiler does not fully support a memset() or
memcpy() with a legal object size (which may be smaller than the largest
number representable with size_t).  There are no plans to address this issue.

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00038639
------------------------------------------------------------------------------

Summary            : Incrementing DOT by zero severely overestimates size of
		     section when MEMORY is high
Affected Component : Linker

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00038659
------------------------------------------------------------------------------

Summary            : C55x assembler runs out of memory
Affected Component : Mnemonic Assembler

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00039305
------------------------------------------------------------------------------

Summary            : Mnemonic assembler doesn't accept valid macro substitution
		     symbol expression for substring
Affected Component : Mnemonic Assembler

Description: 
Mnemonic assembler doesn't accept valid macro substitution symbol
expression for substring.  It emits an error.  Algebraic assembler accepts it 
without error.

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00039567
------------------------------------------------------------------------------

Summary            : Macro library members that don't end in newline crash
		     masm55
Affected Component : Mnemonic Assembler

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00039889
------------------------------------------------------------------------------

Summary            : hex conversion utility does not honor subsections
Affected Component : Hex Converter (hex)

Description: 
Sometimes a section is automatically split in which case you will end
up with sections such as .const1, .const2, etc.  In this scenario the
hex conversion utility has issues in the case where you are defining
SECTIONS within your hex command file.	For example
    .const		paddr=boot

The above would generate this warning
    >> warning section .const not found in Release\executable.out

The hex conversion utility should be fixed in order to recognize
.const1, .const2, etc as subsections of .const.  

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00040719
------------------------------------------------------------------------------

Summary            : When using relocatable code, debugger fails to properly
		     correlate the current overlayed code with the source code.
Affected Component : COFF Linker

Description: 
Relocatable code overlays the same memory addresses with different code
during execution. This overlay is dependent on the context of execution
and the debugger is not able to properly correlate this context with
the source code under execution.

Several views (Watch, Disassembly, Source) fail to properly display the
code and data.	Breakpoints also fail to be active in the execution
context. 

This problem will occur only when using COFF object format with DWARF
debug directives.

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00040934
------------------------------------------------------------------------------

Summary            : Structure is not initialized correctly when using -o2 or
		     -o3 optimization
Affected Component : Optimizer

Description: 
There is a problem with the initialization of a structure using symbols
generated in the linker command file. 

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00041434
------------------------------------------------------------------------------

Summary            : Compiler optimizes away calls to assert without reason
Affected Component : Absolute Lister

Description: 
In certain instances, the compiler incorrectly removes a call to the
assert function.

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00042470
------------------------------------------------------------------------------

Summary            : Compiler generates assembly code which reports invalid
		     syntax error
Affected Component : C/C++ Compiler (cl)

Description: 
Compiler generates the mnemonic assemler instruction RPT with a negative 
argument which is then rejected by the assembler.
